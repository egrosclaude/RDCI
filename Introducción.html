<!doctype html>
<html lang="es">
	<head>
		<meta charset="utf-8">
		<title>Redes de Computadoras I</title>
		<meta name="description" content="Redes de Computadoras I">
		<meta name="author" content="Eduardo Grosclaude">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
		<link rel="stylesheet" href="reveal.js/css/reveal.css">
		<link rel="stylesheet" href="reveal.js/css/theme/rdci.css" id="theme">
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css"> 
		<link rel="icon" type="image/png" href="img/favicon-96x96.png" sizes="96x96">
		<meta name="theme-color" content="#ffffff">
		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
 		<link rel="stylesheet" type="text/css" href="reveal.js/plugin/asciinema/asciinema-player.css" />
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<!--[if lt IE 9]>
		<script src="reveal.js/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>
	<body>
	  <div class="reveal">
		<div class="slides">

<!------------------------------------------------------------------>


<!------------------------>
<section data-background="img/background01.jpg" data-transition="slide-in slide-out">
<div class="frosted">
	<h3>Redes de Computadoras I</h3>
	<h2>Introducción</h2>
</div>
<aside data-markdown class="notes">
</aside>
</section>
<!------------------------>
<!------------------------>
<section data-transition="slide-in slide-out">
<h2>Componentes de las redes</h2>
<ul>
	<div class="fragment color1">
	<li>Borde</li>
	<ul>
		<li>Computadoras de escritorio, portátiles, celulares, sensores, servidores</li>
		<li><b>Sistemas finales, sistemas extremos o hosts</b></li>
	</ul>
	</div>
	<div class="fragment color2">
	<li>Núcleo</li>
	<ul>
		<li>Routers, switches</li>
		<li>En general, <b>nodos de conmutación</b></li>
	</ul>
	</div>
	<div class="fragment color3">
	<li>Vínculos o enlaces</li>
	<ul>
		<li>Propios (LAN) o contratados (MAN, WAN)</li>
	</ul>
	</div>
</ul>
<!-- <img src="img/IMAGEN.png" class="plain stretch"> -->
<aside data-markdown class="notes">
</aside>
</section>


<!------------------------>
<section data-transition="slide-in slide-out">
<h2>Aplicaciones distribuidas</h2>
<ul>
	<li>Las aplicaciones corren en los sistemas finales</li>
	<ul>
		<li>WWW, E-mail, mensajería instantánea, telefonía, juegos en red, archivos compartidos, videoconferencia</li>
		<li class="fragment">Tienen diferentes requerimientos de ancho de banda, de confiabilidad, de temporización</li>
	   <span class="fragment">
		<li>La red les ofrece dos tipos básicos de servicio de transporte</li>
		<ul>
			<li class="color1">Orientado a conexión, confiable (<b>TCP</b>)</li>
			<li class="color2">No orientado a conexión, no confiable (<b>UDP</b>)</li>
		</ul>
	   </span>
	</ul>
</ul>
<!-- <img src="img/imagen.png" class="plain stretch"> -->
<aside data-markdown class="notes">
</aside>
</section>
<!------------------------>
<!------------------------>
<section data-transition="slide-in slide-out">
<h2>Conmutación de circuitos</h2>
<ul>
	<li>Telefonía tradicional</li>
	<li>Antes de empezar a transmitir datos:</li>
	<ul>
		<li>La red establece una conexión dedicada, de extremo a extremo</li>
		<li>Reserva ancho de banda de cada enlace a lo largo de la conexión</li>
		<li>El ancho de banda reservado se desperdicia mientras los sistemas finales no transmiten</li>
	</ul>
</ul>
<!--
<img src="img/imagen.png" class="plain stretch">
-->
<aside data-markdown class="notes">
Existen dos maneras para llevar a cabo la transmisión de datos a través de una red de enlaces y conmutadores (switches y/o routers). A continuación los describimos:
				

**Conmutación por circuitos**

En las redes que implementan este tipo de conmutación, los enlaces que conectan a conmutadores y terminales poseen una cierta cantidad de circuitos y cada uno de estos se destina a una conexión en particular. Por lo tanto, un enlace con N circuitos podrá soportar hasta N conexiones simultáneas.

**_ La característica distintiva de una red basada en conmutación por circuitos es que para establecer una conexión entre dos terminales se debe previamente reservar los recursos que se van a emplear en ella, es decir que se va a reservar un circuito de cada enlace que conecta al par de terminales. _**


Los recursos que reservó una conexión solo pueden ser empleados por ella durante el tiempo que dure. Esto significa que una conexión no comparte sus recursos con otra.

Existen dos formas para implementar los circuitos de un enlace:

	1. Multiplexación por división de frecuencia (FDM)
	2. Multiplexación por división en el tiempo (TDM)

1. Multiplexación por división de frecuencia (FDM): el espectro de frecuencias del enlace es dividido en varias bandas, cada una ellas se asignará a una conexión en particular, durante la duración de la misma. Luego, cada circuito obtiene de forma contínua una fracción del ancho de banda del enlace.
Por ejemplo, los sistemas de televisión por cable implementan este tipo de conmutación: el espectro de frecuencias del enlace es dividida en varias bandas, cada una de ellas es asignada a una "emisora" o "canal" determinado.

2. Multiplexación por división en el tiempo (TDM): el tiempo es dividido en marcos de una determinada longitud, y cada marco se subdivide en una cantidad fija de  "slots". Cada uno de estos slots está dedicado a una determinada conexión, solo ella puede usarlo para el transporte de datos. Entonces, cuando se establece un enlace mediante la red, se asigna a esta conexión un slot de cada marco, que no son compartidos.
A diferencia de FDM, en TDM cada circuito ocupa el total del ancho de banda del enlace durante el "slot" de tiempo que tiene asignado.





_Ana Candelaria Alvarez, Nahuel Mamani_


</aside>
</section>
<!------------------------>
<!------------------------>
<section data-transition="slide-in slide-out">
<h2>Conmutación de paquetes</h2>
<ul>
	<li>El flujo de información se descompone en paquetes</li>
	<li>Cada paquete es transportado separadamente</li>
	<li><b>Store and Forward</b>: cada paquete se almacena en el nodo de conmutación antes de reenviarlo</li>
	<ul>
		<li>Se usa información de destino que viaja junto con el paquete</li>
		<li>Cada nodo de conmutación reenvía el paquete desde el enlace por donde llega, al siguiente</li>
	</ul>
</ul>
<!--
<img src="img/imagen.png" class="plain stretch">
-->
<aside data-markdown class="notes">
**Conmutación por paquetes**

Este tipo de conmutación se aplica en las redes actuales, y su característica principal es que **_los mensajes transmitidos entre dos nodos son divididos en porciones más pequeñas de datos que se denominan paquetes.**_ Cada paquete se conforma por los datos a enviar y por la información de control.

Para que el mensaje llegue correctamente desde el nodo transmisor al receptor, los paquetes correspondientes viajan a través del enlace de comunicaciones y de los conmutadores de paquetes, que se ubican en la capa de enlace y son los routers y los switches. En este momento entra en juego la información de control, cuya función es indicar qué ruta debe seguir el paquete hasta llegar a destino. Cada router posee una tabla de reenvio, que basicamente establece una correspondencia entre direcciones de destino y enlaces salientes.

En general, los conmutadores utilizan el método de transmisión almacenamiento y reenvío (store and forward). Esto significa que el paquete debe llegar y almacenarse completo en el conmutador, y recién entonces podrá comenzar su transmisión al enlace de salida. Para implementar este método, el conmutador tiene que tener algún tipo de memoria interna, denominada buffer o cola de salida y se utiliza para un enlace específico de los varios conectados al conmutador. El tiempo demorado para que el paquete llegue completo y se almacene en el conmutador se denomina retardo de almacenamiento, y se analizará más adelante.

Según la velocidad del enlace y la cantidad de paquetes para transmitir, puede ocurrir que los paquetes lleguen más rápido al conmutador de lo que salen al enlace. En estos casos, la cola o buffer comienza a llenarse y se generan retardos de cola. Un fenómeno que puede ocurrir es la pérdida de paquetes; ocurre cuando un paquete desea entrar al conmutador y almacenarse en el buffer correspondiente pero éste se encuentra lleno

**Conclusiones**

La _conmutación por circuitos_ es ideal para aquellas redes en las cuales se emplearán aplicaciones de tiempo real, por ejemplo videollamadas, porque el retardo que hay entre el envío de un dato desde un terminal y la recepción del mismo en otro terminal generalmente no varía. En cambio, en la conmutación por paquetes las conexiones no poseen enlaces dedicados, por lo que existen retardos  variables e impredecibles, al tener que esperar a que el enlace se desocupe para transmitir un dato.

Por otra parte, quienes argumentan a favor de la _conmutación por paquetes_ afirman que permite un mejor uso compartido del ancho de banda y en comparación es mas económica, sencilla y eficiente. El mejor uso compartido se justifica ya que en este tipo de conmutación los enlaces no son dedicados, por lo que no ocurriría que cierto enlace tenga un periodo ocioso y desperdicie recursos. Además, puede explorarse todo el ancho de banda, permitiendo mas usuarios conectados a la vez. El uso del enlace se denomina bajo demanda; dependiendo de la cantidad de usuarios simultáneos van a tener dedicado más o menos ancho de banda. Esta forma de compartir recursos según lo requerido, se denomina multiplexación estadística de recursos.


_Ana Candelaria Alvarez, Nahuel Mamani_
</aside>
</section>
<!------------------------>


<!------------------------>
<section data-transition="slide-in slide-out">
<h2>Protocolos</h2>
<ul>
	<li>Definen:</li>
	<ul>
		<li>Formato y orden de los mensajes que serán intercambiados entre las entidades que se comunican</li>
		<li>Acciones a tomar ante la recepción de un mensaje u otro evento</li>
	</ul>
   <span class="fragment">
	<li>Un autómata para cada entidad</li>
	<li>Transiciones disparadas por mensajes u otros eventos</li>
   </span>
</ul>
<!--
<img src="img/imagen.png" class="plain stretch">
-->
<aside data-markdown class="notes">
##Protocolos

Los protocolos definen el formato y el orden de los mensajes intercambiados entre dos o más entidades, como así también las acciones llevadas a cabo a partir de la emisión o recepción de un mensaje u otro evento. 

Los protocolos de red son similares a los protocolos humanos, excepto que las entidades que intercambian mensajes y llevan a cabo acciones son componentes de hardware y software de algún dispositivo. 

El intercambio de mensajes entre dos personas se asemeja mucho al intercambio de peticiones que se dan entre un cliente y un servidor. Supongamos que dos personas quieren iniciar una conversación: la conducta normal sería esperar a que alguna de ellas empiece con un saludo, y una vez que la otra persona responde, ambas empezarían a hablar. En los protocolos de red pasa algo similar. El cliente envía un mensaje de saludo al servidor, y si no hay ningún problema, el servidor le devuelve un mensaje diciendo que está dispuesto a empezar una comunicación. Una vez que la conexión está establecida, el cliente y el servidor pueden intercambiar datos relevantes para su correcto funcionamiento. 

No respetar un protocolo puede hacer muy difícil la comunicación. Todas las actividades en Internet que involucran comunicaciones entre dos o más entidades remotas son gobernadas por un protocolo. 

* Por ejemplo, los protocolos de hardware entre dos máquinas conectadas controlan el flujo de bits que llega a través del cable que conecta las dos placas de red. 
* Los protocolos de control de congestión controlan el ritmo en que los paquetes son transmitidos entre el emisor y el receptor. 
* Los protocolos en el router determinan el camino que van a tomar los paquetes desde el origen hasta el destino. 

En general, Internet y las redes de computadoras hacen un uso extensivo de distintos protocolos para llevar a cabo distintas tareas de comunicación. 

_Nahir Saddi-Nicolás Panozo-Sebastián López Mesa-Jordan Fingerhut_
</aside>
</section>
<!------------------------>
<!------------------------>
<section data-transition="slide-in slide-out">
<h2>Medios físicos</h2>
	<div class="double">
	<div>
	Medios guiados<hr>
	<ul>
	<li>Cobre</li>
		<ul>
		<li>Pares trenzados, coaxial</li>
		</ul>
	<li>Fibra óptica</li>
	</ul>
	</div>
	<p></p>
	<div>
	Medios no guiados<hr>
	<ul>
	<li>Inalámbricos o <b>Wireless</b></li>
		<ul>
		<li>Bluetooth</li>
		<li>WiFi</li>
		<li>Microondas terrestres</li>
		<li>Satélites</li>
		</ul>
	</ul>
	</div>
	</div>

<!-- <img src="img/imagen.png" class="plain stretch"> -->
<aside data-markdown class="notes">
</aside>
</section>
<!------------------------>

<!------------------------>
<section data-transition="slide-in slide-out">
<h2>Redes de acceso</h2>
<ul>
	<li>Medios e interfaces</li>
	<ul>
	<li>La interfaz es el dispositivo de un sistema, final o intermedio, donde se conecta a un medio</li>
	<li>El sistema intercambia bits con el medio a través de la interfaz</li>
	</ul>
   <span class="fragment">
	<li>Red local &rarr; Ethernet</li>
	<li>Proveedores de servicio de Internet, <b>ISPs</b></li>
	<ul>
	<li>Dial-up, ADSL</li>
	<li>Proveedores de cable</li>
	</ul>
   </span>
</ul>
<!--
<img src="img/imagen.png" class="plain stretch">
-->
<aside data-markdown class="notes">
</aside>
</section>
<!------------------------>
<!------------------------>
<section data-transition="slide-in slide-out">
<h2>Internet, red de redes</h2>
<ul>
	<li>Jerarquía débil de redes</li>
	<li>IP (<b>Internet Protocol</b>) las atraviesa a todas</li>
   <span class="fragment">
	<li>Niveles de ISPs o <b>tiers</b></li>
	<ul>
	<li>Tier 1, centro de la Internet</li>
	<ul>
		<li>Vínculos intercontinentales</li>
	</ul>
	<li>Un ISP de tier $n$ ofrece conexión a los de tier $n+1$</li>
	<li>ISP regionales o locales conectan a usuarios finales</li>
	</ul>
   </span>
</ul>
<!--
<img src="img/imagen.png" class="plain stretch">
-->
<aside data-markdown class="notes">
</aside>
</section>
<!------------------------>

<!------------------------>
<section data-transition="slide-in slide-out">
<h2>Encolamiento y pérdida</h2>
<ul>
	<li>En cada nodo de conmutación</li>
	<ul>
		<li class="fragment">Los paquetes se encolan frente a la interfaz de salida</li>
		<li class="fragment">Sufren <b>retardo de encolamiento</b> proporcional a la longitud de la cola</li>
		<li class="fragment">Puede existir pérdida (<b>loss</b>) si no hay espacio de buffering en la cola</li>
	</ul>
   <span class="fragment">
	<li>Otros factores de retardo</li>
	<ul>
	<li><b>De procesamiento</b></li>
	<li><b>De transmisión</b></li>
	<li><b>De propagación</b></li>
   </span>
	</ul>
</ul>
<!--
<img src="img/imagen.png" class="plain stretch">
-->
<aside data-markdown class="notes">
##**Encolamiento y pérdida**

La transferencia de paquetes entre dos nodos de una red está dado por dos instancias precisas: el **envìo de paquetes** en el nodo emisor y la **recepción de paquetes** en el nodo receptor.

Para el envío de los paquetes, cada nodo emisor tiene una determinada velocidad de transferencia (a la que viajan los mismos) estos se transmiten -en la medida posible determinada por el ancho de banda del canal de transmisión- uno a uno por el canal. 

Cuando éste está ocupado, los paquetes quedan almacenados en la **memoria intermedia de salida**, también llamada **cola de salida**.

####**Encolamiento**
El llamado *encolamiento* de paquetes sucede cuando la velocidad de transmisión del nodo emisor es superior a la velocidad de recepción del nodo receptor, esto produce la saturación del *buffer* que puede contenerlos, haciendo de esta manera se genere una cola de paquetes, esperando para ser transmitidos, puede ocurrir el llenado de la cola de transmisión y esto nos puede traer algunos problemas subyacentes como es la **pérdida de paquetes**.

####**Pérdida de paquetes**
La *pérdida de paquetes* por el llenado de  la cola de salida ocurre cuando un paquete quiere salir por el enlace del nodo emisor y se encuentra con que no solo el enlace está ocupado sino que también está completa la *memoria intermedia de salida*(cola de salida), entonces en este caso quedan dos soluciones, el paquete que intentó ingresar a la *cola de salida* se pierde o se da de baja algún paquete que ya se encuentra en la memoria intermedia de salida.

####**Otros factores de retardo**
Cuando un paquete se quiere transmitir de un nodo de salida a otro nodo destino ,muy probablemente en el proceso de emisión, recorre distintos nodos intermedios para poder llegar a destino. En este recorrido pueden ocurrir una serie de factores, que generan distintos tipos de retardo, como son los **retardo de procesamiento**, **retardo de transmisión**, **retardo de propagación** y como antes se explicó la *demora de espera* que ocurre cuando el enlace emisor está ocupado y probablemente también se encuentres paquetes en la memoria intermedia.

####**Retardo de procesamiento**
Es el tiempo en que se demora en verificar en qué enlace se enviará el paquete, esto se conoce al analizar su encabezado, luego de conocerlo se envía el paquete al destino, otro control que se realiza es que no se produzca un error a nivel de bit al enviar el paquete al nodo en que nos encontramos analizando.



####**Retardo de transmisión**
Es el tiempo necesario para introducir todos los bits del paquete por el enlace para luego transmitirlos, en la práctica sólo puede ser transmitido después de que todos los paquetes que hayan llegado antes hayan sido transmitidos.


####**Retardo de propagación**
Una vez que el bit haya entrado por el enlace (de transmisión), este debe propagarse al router de destino. La velocidad de propagación depende del medio físico del enlace (fibra óptica, cable de cobre,satélite). 
El retardo de propagación es igual a, la distancia entre dos routers dividida por la velocidad de propagación.

_Daiana Natalí Bonet Peinado_


# Encolamiento y pérdida

Cuando se realiza transferencia de datos, estos se dividen en paquetes que se transfieren de un nodo a otro hasta alcanzar su destino final (borde de la red) o morir en el camino (en el núcleo de la red). 

En cada etapa del proceso de transmisión de los paquetes ocurren diversos retardos en el núcleo de la red:

Cuando un paquete llega a un nodo (llamémosle nodo A), éste verifica el encabezado del paquete para saber a qué interfaz de salida debe redirigirlo. Si el link por el cual debe enviar el paquete está ocupado, el paquete se pone en el buffer de salida que le corresponda a ese link y se encola hasta ser dirigido. Este tiempo que tarda en verificar el encabezado se llama *retardo de procesamiento*. Además de verificar el encabezado, el tiempo de procesamiento también puede verse incrementado por la comprobación de posibles errores a nivel de bit que pueden producirse en el envío del paquete desde el nodo anterior al nodo A. 

Cuando el paquete está en el buffer esperando a ser transmitido, sufre *retardo por encolamiento*, el cual es proporcional a la cantidad de paquetes que están delante de él (teniendo en cuenta que el buffer es atendido en orden de llegada –first come first serve-). Si no existen paquetes delante de él, el tiempo de retardo por encolamiento es cero; de lo contrario si hay muchos paquetes esperando a ser atendidos el tiempo de retardo por encolamiento es muy alto. 

Cuando el nodo está listo para transmitir el paquete, debe tomar bit por bit e ir colocándolos en el link. Este tiempo que tarda en colocar los bits en el link se llama *retardo de transmisión*. Supongamos que la cantidad de bit del paquete a transmitir es L, y la tasa de transferencia de bit del link es de R bit por segundos, entonces el retardo de transmisión se calcula como L/R bit por segundos que indica el tiempo que requiere para colocar todos los bits del paquete en el link.

Una vez que los bits del paquete están sobre el link, estos deben llegar al siguiente nodo. Durante el tiempo de viaje de un nodo a otro los bits sufren un tiempo de *retardo por propagación*. Este tiempo se ve afectado por el medio físico por el cual están siendo transmitidos los bits (fibra óptica, cables de pares trenzados de cobre, coaxial, etc.) y la longitud del camino entre los nodos.

Pérdida de paquetes: 

En el momento que el paquete debe ponerse en el buffer para ser transmitido al link, puede suceder que el buffer no tenga suficiente memoria para guardarlo, en tal caso la acción que se toma es eliminar el paquete, es decir el paquete se pierde en ese nodo y no es transmitido a ningún sitio.

</aside>

</section>
<!------------------------>
<!------------------------>
<section>
<section data-transition="slide-in slide-out">
<h2>Retardos</h2>
<ul>
	<li>Críticos para la performance de las aplicaciones</li>
	<li>Se suman para dar el retardo total de un enlace</li>
   <div class="fragment color1">
	<li>Retardo de transmisión</li>
	<ul>
		<li>Depende de la cantidad de bits y de la interfaz</li>
		<li>$t_{transm} = L / v_{transm}$</li>
	</ul>
   </div>
   <div class="fragment color2">
	<li>Retardo de propagación</li>
	<ul>
		<li>Depende de la longitud del vínculo y de $c$</li>
		<li>$t_{prop} = D / v_{prop} = D / c$</li>
	</ul>
   </div>
</ul>
<!--
<img src="img/imagen.png" class="plain stretch">
-->
<aside data-markdown class="notes">
</aside>
</section>
<!------------------------>

<!------------------------>
<section data-transition="convex-in slide-out">
<h2>Comando traceroute</h2>
 <div class="asciicast"><!-- { "URL": "src/traceroute.json" } --></div>
<!-- <img src="img/IMAGEN.png" class="plain stretch"> -->
<aside data-markdown class="notes">
</aside>
</section>
<!------------------------>
</section>
<!------------------------>
<section data-transition="slide-in slide-out">
<h2>Capas de protocolos</h2>
<ul>
	<li>Pila o <b>stack</b> de protocolos</li>
	<li>Modelo de capas ISO/OSI</li>
   <div class="fragment postit">
	<li>Modelo de capas de Internet</li>
	<ul>
		<li>Aplicación</li>
		<li>Transporte</li>
		<li>Red</li>
		<li>Enlace</li>
		<li>Física</li>
	</ul>
   </div>
   <span class="fragment">
	<li>Cada capa es cliente de la inferior</li>
   </span>
</ul>
<!--
<img src="img/imagen.png" class="plain stretch">
-->
<aside data-markdown class="notes">
</aside>
</section>
<!------------------------>
<!------------------------>
<section data-transition="slide-in slide-out">
<h2>Encapsulamiento</h2>
<div class="double">
<div>
<ul>
	<li>Unidad de datos de protocolo o <b>PDU</b> para cada nivel</li>
	   <span class="fragment">
		<li>Cada capa:</li>
		<ul>
			<li>Encapsula la PDU recibida con su <b>cabecera</b> creando una PDU de su nivel</li>
			<li>Entrega su PDU a la siguiente capa</li>
		</ul>
	   </span>
</ul>
</div>
<div>
   <div class="fragment postit">
	<table>
		<tr><th>Capa</th><th>PDU</th></tr>
		<tr><td>Aplicación</td><td>Mensaje</td></tr>
		<tr><td>Transporte</td><td>Segmento</td></tr>
		<tr><td>Red</td><td>Paquete o datagrama</td></tr>
		<tr><td>Enlace</td><td>Trama, marco o <b>frame</b></td></tr>
	</table>
   </div>
</div>
</div>
<!--
<img src="img/imagen.png" class="plain stretch">
-->
<aside data-markdown class="notes">
</aside>
</section>
<!------------------------>

	
<section class="preguntas" data-background="#2c63d5" data-background-transition="zoom">
<h2>Preguntas</h2>
<ol>
<li>¿Qué aplicaciones de red tienen requerimientos de confiabilidad? ¿Qué aplicaciones <b>no necesitan</b> confiabilidad? ¿Qué aplicaciones de red tienen requerimientos de temporización?</li>
<li>¿Cuál es el propósito de la multiplexión de enlaces? ¿Qué formas de multiplexión se utilizan en conmutación de circuitos, y qué diferencias existen entre ellas?</li>
<li>¿Cuáles son las diferencias entre TDM y multiplexión estadística?</li>
</ol>
</section>


<section class="preguntas" data-background="#2c63d5" data-background-transition="zoom">
<h2>Preguntas</h2>
<ol>
<li>¿Cómo describiría el protocolo que rige la interacción entre un comerciante y su cliente?</li>
<li>¿En qué aplicaciones, entornos o distancias, son recomendables los diferentes tipos de medios?</li>
<li>Dos puntos muy alejados del planeta pueden conectarse mediante cables suboceánicos de fibra óptica o por vínculos satelitales. ¿Qué consecuencias tiene para la comunicación de datos una u otra elección?</li>
</ol>
</section>

<section class="preguntas" data-background="#2c63d5" data-background-transition="zoom">
<h2>Preguntas</h2>
<ol>
<li>¿Por qué motivo se forman colas frente a las interfaces de salida de un nodo de conmutación? ¿Qué ocurre en caso extremo? Agregar más memoria a las colas, ¿es una solución?</li>
<li>¿Qué analogía se puede señalar entre una interfaz que transmite y una persona que habla? En esta analogía, ¿a qué corresponden la velocidad de transmisión y la velocidad de propagación?</li>
</ol>
</section>


<!------------------------>
<section data-transition="slide-in slide-out">
<h2>Referencias</h2>
<ul>
	<li><b>Redes de Computadores, Un Enfoque Descendente</b>, Kurose, Ross, cap. 1</li>
</ul>
<aside data-markdown class="notes">
</aside>
</section>
<!------------------------>
<!------------------------------------------------------------------>
   </div>
</div>

<link rel="stylesheet" href="Tangle/TangleKit/TangleKit.css" type="text/css">
<script type="text/javascript" src="Tangle/Tangle.js"></script>
<script type="text/javascript" src="Tangle/TangleKit/mootools.js"></script>
<script type="text/javascript" src="Tangle/TangleKit/sprintf.js"></script>
<script type="text/javascript" src="Tangle/TangleKit/BVTouchable.js"></script>
<script type="text/javascript" src="Tangle/TangleKit/TangleKit.js"></script>
<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>

	Reveal.initialize({
		controls: true,
		progress: true,
		history: true,
		center: false,
		previewLinks: true,
		theme: 'rdci',
		transition: 'slide', // none/fade/slide/convex/concave/zoom

		// ----------------------------------------------------------------------------
		chart: {
			defaults: { 
				global: { 
					title: { fontColor: "#222" }, 
					legend: {
						position: "bottom",
						labels: { fontColor: "#000", size: "14px" },
					},
					tooltips: {
						labels: { fontColor: "#022", size: "14px" },
					},
				}, 
				scale: { 
					scaleLabel: { fontColor: "#022" }, 
					gridLines: { color: "#444", zeroLineColor: "#444" }, 
					ticks: { fontColor: "#022" }, 
				} 
			},
			line: { borderColor: [ 
				"rgba(20,220,220,.8)" , 
				"rgba(220,120,120,.8)", 
				"rgba(20,120,220,.8)",
				"rgba(220,20,120,.8)",
				"rgba(20,20,220,.8)" ]
			}, 
			bar: { backgroundColor: [ 
				"rgba(20,220,220,.8)" , 
				"rgba(20,120,220,.8)",
				"rgba(20,20,220,.8)",
				"rgba(120,20,220,.8)",
				"rgba(220,120,20,.8)", 
				"rgba(220,20,20,.8)",
			 ]
			}, 
			pie: { backgroundColor: [ 
				["rgba(0,0,0,.8)" , 
				"rgba(220,20,20,.8)", 
				"rgba(20,220,20,.8)", 
				"rgba(220,220,20,.8)", 
				"rgba(20,20,220,.8)"] 
			]},
			radar: { borderColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)" ]}, 
		},
		// ----------------------------------------------------------------------------
		menu: { // Menu works best with font-awesome installed: sudo apt-get install fonts-font-awesome
			themes: false,
			transitions: false,
			markers: true,
			hideMissingTitles: true,
			custom: [
				// { title: 'Plugins', icon: '<i class="fa fa-external-link"></i>', src: 'toc.html' },
				// { title: 'About', icon: '<i class="fa fa-info"></i>', content: '<p>Int Comp</p>' },
				{ title: 'RDCI', icon: '<i class="fa fa-bookmark"></i>', src: 'src/rdci.html' },
				{ title: 'Imprimir', icon: '<i class="fa fa-print"></i>', src: 'src/print.html' },
			]
		},
		// ----------------------------------------------------------------------------
		anything: [ 
			{className: "rand",  defaults: {min: 0, max: 9}, 
				initialize: (function(container, options){ 
					container.innerHTML = Math.trunc( options.min + Math.random()*(options.max-options.min + 1) ); 
			}) },
			{className: "chart",  
				initialize: (function(container, options){ 
					container.chart = new Chart(container.getContext("2d"), options);  
				}) 
			},
			{className: "animate",  
				initialize: (function(container, options){ 
				Reveal.addEventListener( 'fragmentshown', function( event ) {
					if (typeof event.fragment.beginElement === "function" ) { 
						event.fragment.beginElement(); 	
					}
				});
				Reveal.addEventListener( 'fragmenthidden', function( event ) {
					if (event.fragment.hasAttribute('data-reverse') ) { 
						var reverse = event.fragment.parentElement.querySelector('[id=\"' + event.fragment.getAttribute('data-reverse') + '\"]');
						if ( reverse && typeof reverse.beginElement === "function" ) { 
							reverse.beginElement(); 	
						}										 	
					}
				});
				if ( container.getAttribute("data-svg-src") ) { 
					var xhr = new XMLHttpRequest(); 
					xhr.onload = function() { 
						if (xhr.readyState === 4) { 
							var svg = container.querySelector('svg');
							container.removeChild( svg );
							container.innerHTML = xhr.responseText + container.innerHTML;
							if ( svg ) {
								container.querySelector('svg').innerHTML = container.querySelector('svg').innerHTML + svg.innerHTML;
							}
						} 
						else { 
							console.warn( "Failed to get file. ReadyState: " + xhr.readyState + ", Status: " + xhr.status); 
						}
					}; 
					xhr.open( 'GET', container.getAttribute("data-svg-src"), true ); 
					xhr.send();
				}
			}) },
			{className: "tangle", 
				initialize: (function(container, options) { if(options && options.initialize) {options.initialize(container)} }) },
			{className: "plot",  defaults: {width:800, height: 400, grid:true}, 
				initialize: (function(container, options){ options.target = "#"+container.id; functionPlot(options) }) },
			{className: "asciicast",
                                 defaults: { theme: 'monokai', fontSize: '15px' },
                                 initialize: (function(container, options) {
                                         asciinema.player.js.CreatePlayer(container, options.URL, options);
                                 })
                         },
			{className: "anything",  
				initialize: (function(container, options){ if (options && options.initialize) { options.initialize(container)} }) },

		],
		// ----------------------------------------------------------------------------


		// -------- Math plugin ----------
		math: {
			mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
			//	mathjax: '../MathJax-master/MathJax.js',
			config: 'TeX-AMS_HTML-full'
		},


		// -------- Chalkboard -----------
		chalkboard: { 
			// optionally load pre-recorded chalkboard drawing from file
			// src: "chalkboard.json",
			//readOnly: undefined, 
			toggleChalkboardButton: { left: "80px" },
			toggleNotesButton: { left: "130px" },
			//transition: 800,
			//theme: "whiteboard",
			// configuration options for notes canvas and chalkboard
			//color: [ 'rgba(0,0,255,1)', 'rgba(255,255,255,0.5)' ],
			//background: [ 'rgba(127,127,127,.1)' , 'plugin/chalkboard/img/blackboard.png' ],
			//pen:  [ 'reveal.js-plugins/chalkboard/img/boardmarker.png', 'reveal.js-plugins/chalkboard/img/chalk.png' ],
		},
		keyboard: {
			67: function() { RevealChalkboard.toggleNotesCanvas() },    // toggle notes canvas when 'c' is pressed
			66: function() { RevealChalkboard.toggleChalkboard() }, // toggle chalkboard when 'b' is pressed
			46: function() { RevealChalkboard.clear() },    // clear chalkboard when 'DEL' is pressed
			 8: function() { RevealChalkboard.reset() },    // reset chalkboard data on current slide when 'BACKSPACE' is pressed
			68: function() { RevealChalkboard.download() }, // downlad recorded chalkboard drawing when 'd' is pressed
			82: function() { Recorder.toggleRecording(); }, // press 'r' to start/stop recording
			90: function() { Recorder.downloadZip(); },     // press 'z' to download zip containing audio files
			84: function() { Recorder.fetchTTS(); }     // press 't' to fetch TTS audio files
		},

		// -------- Dependencies ---------
		dependencies: [
			{ src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
			{ src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
			{ src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
			// { src: 'plugin/notes/notes.js', async: true },
			{ src: 'reveal.js/plugin/explain/explain.js', async: true },
			{ src: 'reveal.js/plugin/function-plot/site/js/vendor/jquery-1.11.2.min.js' },
			{ src: 'reveal.js/plugin/function-plot/site/js/vendor/d3.js' },
			{ src: 'reveal.js/plugin/function-plot/dist/function-plot.js' },
			{ src: 'reveal.js/plugin/chart/Chart.min.js'},
			// { src: 'reveal.js/plugin/search/search.js', async: true},
			{ src: 'reveal.js/plugin/chart/csv2chart.js'},
			{ src: 'reveal.js/plugin/asciinema/asciinema-player.js' },
			{ src: 'reveal.js/plugin/anything/anything.js' },
			{ src: 'reveal.js/plugin/chalkboard/chalkboard.js' },
			{ src: 'reveal.js/plugin/menu/menu.js' },
			{ src: 'reveal.js/plugin/mathsvg/math.js', async: true },
			//{ src: 'reveal.js/plugin/audio-slideshow/slideshow-recorder.js', condition: function( ) { return !!document.body.classList; } },
			//{ src: 'reveal.js/plugin/audio-slideshow/audio-slideshow.js', condition: function( ) { return !!document.body.classList; } },
			// ... 
		]
	});
</script>

</body>
</html>
